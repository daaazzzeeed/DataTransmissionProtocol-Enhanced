//
// Created by dazzzed on 20.02.2021.
//

#include "Device.h"
#include "Router.h"

Device::Device(int address, int dispatchInterval)
{
    this->address = address;
    name = "device at 0x" + std::to_string(address);
    dataDispatchInterval = dispatchInterval;
    parentRouter = nullptr;
    timeToNextDispatch = dataDispatchInterval;
    deltaTime = 1;
    dataToSendRaw = {};
    dataToSendPrepared= {};
    inDataRaw = {};
    inDataProcessed = {};
    statistics = {0, 0, 0};
    currentTime = 0;
    state = states::Idle;
}

void Device::Run() {
    //std::cout << name + " : TTND: " << timeToNextDispatch << std::endl;
    //std::cout << name + " : Data to send prepared left: " << dataToSendPrepared.size() << std::endl;

    int response = 0;

    std::cout << "Device at " << address << ", state: " << state << std::endl;

    switch (state)
    {
        case states::Idle:

            if (inDataRaw.size() > 0)
            {
                state = states::Receiving;
            }
            // check if device can send
            if (dataDispatchInterval != -1)
            {
                // check if it's time to send new request
                if (timeToNextDispatch == 0)
                {
                    // check if data was not already created
                    if (dataToSendPrepared.empty())
                    {
                        // create data
                        GenerateData(); // initially generate new data
                        std::cout << "Package " << vector_to_string(dataToSendRaw) << " was generated by " << name
                                  << std::endl;
                        std::ofstream file;
                        file.open("stats.txt", std::ios::app);
                        file << currentTime << ": created " << vector_to_string(dataToSendRaw) << "\n";
                        file.close();
                    }

                    // if device has no created request
                    if (requestRaw.empty())
                    {
                        // create send request
                        GenerateRequest();
                    }

                    if (!requestRaw.empty() && requestPrepared.empty())
                    {
                        PrepareRawData();
                    }


                    // achieve sending request state
                    state = states::SendingRequest;
                }
            }
            break;
        case states::SendingRequest:
            if (!SendRequest())
            {
                // no data to send
                // (all data was successfully sent)

                // achieve state awaiting response
                state = states::AwaitingResponse;
            }
            // otherwise data was successfully sent
            break;
        case states::AwaitingResponse:
            response = CheckInData();

            // ok response
            if (response == 1)
            {
                std::cout << "Response = " << response << std::endl;
                std::ofstream file;
                file.open("stats.txt", std::ios::app);
                std::cout << currentTime << ": approved " << vector_to_string(dataToSendRaw) << "\n";
                file << currentTime << ": approved " << vector_to_string(dataToSendRaw) << "\n";
                file.close();

                // achieve new state
                state = states::SendingData;

                // clear old request data
                requestRaw.clear();
                requestPrepared.clear();
                inDataProcessed.clear();
            }

            // bad response
            if (response == 2)
            {
                std::cout << "Response = " << response << std::endl;
                std::ofstream file;
                file.open("stats.txt", std::ios::app);
                file << currentTime << ": denied " << vector_to_string(dataToSendRaw) << "\n";
                std::cout << currentTime << ": denied " << vector_to_string(dataToSendRaw) << "\n";
                file.close();

                // achieve Idle state
                // keep old request data
                state = states::Idle;
                inDataProcessed.clear();
            }
            break;
        case states::SendingData:

            // if all data was sent
            if (!SendData())
            {
                // display message
                std::cout << "Package " << vector_to_string(dataToSendRaw) << " was sent by " << name << std::endl;

                // write to stats
                statistics[0]++;
                // clear raw data to send (prepared data already is empty)
                dataToSendRaw.clear();

                // achieve idle state
                state = states::Idle;
            }
            // otherwise part of data was successfully sent
            break;
        case states::Receiving:

            if (CheckInData() == 0)
            {
                std::cout << name << " got message " << vector_to_string(inDataProcessed) << std::endl;
                std::ofstream file;
                file.open("stats.txt", std::ios::app);
                file << currentTime << ": received " << vector_to_string(inDataProcessed) << "\n";
                file.close();
                inDataProcessed.clear();
                state = states::Idle;
            }

            break;
        default:
            std::cout << "State error!\nWrong state was set!" << std::endl;
            break;
    }

    if (timeToNextDispatch > 0)
    {
        timeToNextDispatch -= deltaTime;
    }
    else
    {
        timeToNextDispatch = dataDispatchInterval-1;
    }
    currentTime += deltaTime;
}

void Device::GenerateData()
{
    // first remove all data
    dataToSendRaw.clear();

    // add header data and payload size
    std::cout << "*****" << payloadSize << "*****" << std::endl;
    dataToSendRaw = {
                MESSAGE_START,
                address,
                destAddress,
                payloadSize
    };

    // define max and min values in payload
    int max = 251;
    int min = 2;
    int range = max - min;

    // fill the package with payload
    for (int i = 0; i < payloadSize; i++)
    {
        dataToSendRaw.push_back(rand() % range + min);
    }

    // add ending character to a package
    dataToSendRaw.push_back(MESSAGE_END);

    // convert bytes to bits
    for (auto item : dataToSendRaw)
    {
        std::bitset<8> binaryItem(item);

        for (auto bitChar : binaryItem.to_string())
        {
            int bit = bitChar - '0';
            dataToSendPrepared.push_back(bit);
        }
    }

    //std::cout << vector_to_string(dataToSendPrepared) << std::endl;
}
bool Device::SendData()
{
    // device has data to send
    if (dataToSendPrepared.size() > 0)
    {
        // fetch data
        int data = dataToSendPrepared[0];
        //std::cout << data << std::endl;
        // crop vector
        auto first = dataToSendPrepared.begin() + 1;
        auto last = dataToSendPrepared.end();

        dataToSendPrepared = std::vector(first, last);

        // find router's target port
        double targetPort = -1;
        // fetch connected devices of a parent router
        auto connected = parentRouter->GetConnectedDevices();

        // compare each device address to a current address

        for (auto it = connected.begin(); it != connected.end(); it++)
        {
            if (it->second->GetAddress() == address)
            {
                targetPort = it->first;
                break;
            }
        }

        // finally send data to target port
        parentRouter->Receive(data, targetPort);
        return true;
    }

    return false;
}

std::vector<int> Device::GetStatistics()
{
    return statistics;
}

void Device::Receive(int data, int port)
{
    inDataRaw.push_back(data);
}

void Device::Connect(IConnectable* device, int port)
{
    parentRouter = device;
}

std::string Device::GetName()
{
    return name;
}

int Device::CheckInData()
{
    if (inDataRaw.size() == 8)
    {
        std::string binary = "";

        for (auto bit : inDataRaw)
        {
            binary += std::to_string(bit);
        }

        int processedByte = binaryStringToInt(binary);
        inDataProcessed.push_back(processedByte);
        inDataRaw.clear();

        if (inDataProcessed.back() == MESSAGE_END)
        {
            for (auto item : inDataProcessed)
            {
                if (item == RESPONSE_OK)
                {
                    // got ok response
                    std::cout << "resp: " << 1 << std::endl;
                    return 1;
                }
                else if (item == RESPONSE_BAD)
                {
                    // got denied response
                    std::cout << "resp: " << 2 << std::endl;
                    return 2;
                }
            }

            // got message
            std::cout << "resp: " << 0 << std::endl;
            return 0;
        }
    }

    // message not received completely
    return -1;
}

double Device::GetAddress()
{
    return address;
}


std::map<int, IConnectable*> Device::GetConnectedDevices()
{
    return {{0, parentRouter}};
}

void Device::SetDestination(double dest)
{
    destAddress = dest;
}


void Device::SetPayloadSize(double size)
{
    payloadSize = size;
}

bool Device::SendRequest()
{
    // device has data to send
    std::cout << "prepared: " << requestPrepared.size() << std::endl;
    if (requestPrepared.size() > 0)
    {
        // fetch data
        int data = requestPrepared[0];
        //std::cout << data << std::endl;
        // crop vector
        auto first = requestPrepared.begin() + 1;
        auto last = requestPrepared.end();

        requestPrepared = std::vector(first, last);

        // find router's target port
        double targetPort = -1;
        // fetch connected devices of a parent router
        auto connected = parentRouter->GetConnectedDevices();

        // compare each device address to a current address

        for (auto it = connected.begin(); it != connected.end(); it++)
        {
            if (it->second->GetAddress() == address)
            {
                targetPort = it->first;
                break;
            }
        }

        // finally send data to target port
        parentRouter->Receive(data, targetPort);
        return true;
    }
    else
    {
        return false;
    }
}

void Device::GenerateRequest()
{
    // first remove all data
    requestRaw.clear();

    requestRaw = {
            MESSAGE_START,
            REQUEST,
            MESSAGE_END
    };

    // convert bytes to bits
    PrepareRawData();

    //std::cout << vector_to_string(dataToSendPrepared) << std::endl;
}

void Device::PrepareRawData()
{
    // convert bytes to bits
    for (auto item : requestRaw)
    {
        std::bitset<8> binaryItem(item);

        for (auto bitChar : binaryItem.to_string())
        {
            int bit = bitChar - '0';
            requestPrepared.push_back(bit);
        }
    }
}